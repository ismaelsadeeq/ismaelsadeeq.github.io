<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://ismaelsadeeq.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://ismaelsadeeq.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-01-30T17:49:45+00:00</updated><id>https://ismaelsadeeq.github.io/feed.xml</id><title type="html">blank</title><subtitle>Abubakar Sadiq Ismail </subtitle><entry><title type="html">Managing Multiple Projects with Git Worktrees</title><link href="https://ismaelsadeeq.github.io/blog/2026/managing-multiple-projects-with-git-worktrees/" rel="alternate" type="text/html" title="Managing Multiple Projects with Git Worktrees"/><published>2026-01-30T00:00:00+00:00</published><updated>2026-01-30T00:00:00+00:00</updated><id>https://ismaelsadeeq.github.io/blog/2026/managing-multiple-projects-with-git-worktrees</id><content type="html" xml:base="https://ismaelsadeeq.github.io/blog/2026/managing-multiple-projects-with-git-worktrees/"><![CDATA[<p>Git worktrees are a nifty feature that allows me to work on multiple branches simultaneously within a single repository. Instead of constantly switching branches and dealing with uncommitted changes, I use worktrees to provide isolated working directories for each branch.</p> <h4 id="the-problem-with-branch-checkouts">The Problem with Branch Checkouts</h4> <p>When working on multiple features, I often encounter a common scenario: I’m in the middle of implementing a feature with uncommitted changes when I need to switch to another branch. My traditional Git workflow offered two main solutions, each with drawbacks:</p> <ul> <li><strong>Creating wip/intermediate commit:</strong> While this preserves my work, I must recompile the entire codebase when switching branches. Additionally, I need to either amend commits or perform soft resets when returning to my work, cluttering my Git history.</li> <li><strong>Using git stash:</strong> Stashing becomes problematic when I’m managing multiple stashes. I have to remember stash indices or inspect each stash before applying it, often leading to applying the wrong stash to the wrong branch.</li> </ul> <p>Both approaches share another limitation: each time I switch branches and recompile, I lose access to the previous branch’s compiled binaries, making it impossible to run experiments across different projects’ binaries without manually saving them in a separate directory.</p> <h4 id="how-git-worktrees-solve-these-problems">How Git Worktrees Solve These Problems</h4> <p>Git worktrees eliminate these pain points by creating separate working directories for each feature. Instead of switching branches within a single directory, I organise my work into multiple directories, each containing a different branch.</p> <p>I leverage it to organise my repository like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bitcoin-core/
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bitcoin-core/bitcoin/              (main branch)
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bitcoin-core/fee-estimation/       (feature branch)
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bitcoin-core/block-template-cache/ (feature branch)
</code></pre></div></div> <p>Each directory operates independently with its own working tree, staged changes, and compiled binaries. I can open my editor in any directory and work without affecting the others.</p> <h4 id="creating-a-new-worktree">Creating a New Worktree</h4> <p>Creating a worktree is straightforward. From my main repository, I use the <code class="language-plaintext highlighter-rouge">git worktree add</code> command:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git worktree add ../scaling-btc
</code></pre></div></div> <p>This creates a new directory at the specified path with a clean checkout of my repository. I can now navigate to that directory and work independently:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ../scaling-btc
nvim <span class="nb">.</span>
</code></pre></div></div> <p>When I need to switch contexts, I simply navigate to a different worktree directory. No recompilation needed, no stash management required.</p> <h4 id="handling-untracked-files">Handling Untracked Files</h4> <p>One limitation of worktrees is that they only include Git-tracked files. Configuration files, build scripts, and environment files that aren’t tracked by Git won’t be copied to new worktrees. However, I easily solve this with a post-checkout hook.</p> <p>A post-checkout hook is a Git script that runs automatically after I check out a branch. I use it to copy necessary files from my main repository to new worktrees.</p> <h4 id="setting-up-a-post-checkout-hook">Setting Up a Post-Checkout Hook</h4> <p>I create the hook file at <code class="language-plaintext highlighter-rouge">.git/hooks/post-checkout</code> in my main repository:</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="c">#!/usr/bin/env bash</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"0000000000000000000000000000000000000000"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nv">main_git_dir</span><span class="o">=</span><span class="si">$(</span>git rev-parse <span class="nt">--git-common-dir</span><span class="si">)</span>
    <span class="nv">main_work_tree</span><span class="o">=</span><span class="si">$(</span><span class="nb">dirname</span> <span class="s2">"</span><span class="nv">$main_git_dir</span><span class="s2">"</span><span class="si">)</span>
    <span class="nv">work_tree</span><span class="o">=</span><span class="si">$(</span>git rev-parse <span class="nt">--show-toplevel</span><span class="si">)</span>
    <span class="nb">cp</span> <span class="s2">"</span><span class="nv">$main_work_tree</span><span class="s2">/.envrc"</span> <span class="s2">"</span><span class="nv">$work_tree</span><span class="s2">/.envrc"</span>
    <span class="nb">cp</span> <span class="s2">"</span><span class="nv">$main_work_tree</span><span class="s2">/.env"</span> <span class="s2">"</span><span class="nv">$work_tree</span><span class="s2">/.env"</span>
    <span class="nb">cp</span> <span class="s2">"</span><span class="nv">$main_work_tree</span><span class="s2">/build_and_test.sh"</span> <span class="s2">"</span><span class="nv">$work_tree</span><span class="s2">/build_and_test.sh"</span>
    <span class="nb">cd</span> <span class="s2">"</span><span class="nv">$work_tree</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> direnv allow <span class="o">&amp;&amp;</span> <span class="nb">chmod</span> +x build_and_test.sh
    <span class="nb">echo</span> <span class="s2">"worktree setup completed"</span>
<span class="k">fi</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>This script does the following:</p> <ol> <li>Detects when a new worktree is being created by checking for the special commit hash.</li> <li>Identifies the main repository directory using <code class="language-plaintext highlighter-rouge">git rev-parse --git-common-dir</code>.</li> <li>Copies necessary files from the main repository to the new worktree.</li> <li>Makes scripts executable.</li> </ol> <p>Make the hook executable:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> +x .git/hooks/post-checkout
</code></pre></div></div> <p>Now, whenever I create a new worktree, the hook automatically copies my configuration files, ensuring each worktree has everything it needs to function properly.</p> <p>Happy Hacking :)</p> <h4 id="references">References</h4> <ul> <li><a href="https://mskelton.dev/bytes/using-git-hooks-when-creating-worktrees">Using Git Hooks When Creating Worktrees</a></li> <li><a href="https://git-scm.com/docs/githooks/2.10.5">Git Hooks Documentation</a></li> <li><a href="https://git-scm.com/docs/git-worktree">Git Worktree Documentation</a></li> </ul>]]></content><author><name></name></author><category term="technical"/><category term="git"/><category term="productivity"/><category term="workflow"/><summary type="html"><![CDATA[A guide to using Git worktrees for managing multiple branches and tasks simultaneously.]]></summary></entry><entry><title type="html">Determining BlockTemplate Fee Increase Using Fee Rate Diagram</title><link href="https://ismaelsadeeq.github.io/blog/2025/detecting-blocktemplate-fee-increase-using-feerate-diagram/" rel="alternate" type="text/html" title="Determining BlockTemplate Fee Increase Using Fee Rate Diagram"/><published>2025-10-13T00:00:00+00:00</published><updated>2025-10-13T00:00:00+00:00</updated><id>https://ismaelsadeeq.github.io/blog/2025/detecting-blocktemplate-fee-increase-using-feerate-diagram</id><content type="html" xml:base="https://ismaelsadeeq.github.io/blog/2025/detecting-blocktemplate-fee-increase-using-feerate-diagram/"><![CDATA[<h4 id="motivation-and-background">Motivation and Background</h4> <p>Currently, when miners want to determine whether a block template with more fees is available, they repeatedly poll the <code class="language-plaintext highlighter-rouge">getblocktemplate</code> RPC until a better template is returned (relative to the one they are working on). This approach can lead to redundant block template builds in some cases.</p> <p>The experimental mining interface introduced in <a href="https://delvingbitcoin.org/t/bitcoin-core-v30-0-released/2050">Bitcoin Core v30</a>, <code class="language-plaintext highlighter-rouge">waitnext()</code>, improves this by allowing clients to wait and receive a new block template after a noticeable fee increase or when the blockchain tip changes.</p> <p>However, internally, <code class="language-plaintext highlighter-rouge">waitnext()</code> also regenerates block templates every second. Building a block template locks Bitcoin Core mutexes, (mempool (<code class="language-plaintext highlighter-rouge">cs</code>) and <code class="language-plaintext highlighter-rouge">cs_main</code>) throughout the build. These locks prevent concurrent access during template generation for thread safety purpose, which can delay transaction processing and relay to peers.</p> <p>A better approach is to <strong>track the potential fee increase</strong> resulting from each mempool update that affects the current block template. The node can then decide whether rebuilding the template is worthwhile based on the accumulated fee increase.</p> <p>Implementing this in current Bitcoin Core is challenging because, for each mempool update, the <strong>effective chunk fee rate</strong> of affected transactions is not explicitly known [0].</p> <p>However, with the introduction of the <strong>Cluster Mempool</strong> [1], this limitation no longer applies.</p> <p>This post explores a simple method that leverages Cluster Mempool feature to determine whether there has been a potential <strong>fee rate improvement</strong> in a block template without requiring a full rebuild.</p> <h4 id="prerequisites">Prerequisites</h4> <ul> <li><a href="https://delvingbitcoin.org/t/cluster-mempool-definitions-theory/202">Cluster Mempool Definitions</a></li> <li><a href="https://delvingbitcoin.org/t/mempool-incentive-compatibility/553">Mempool Incentive Compatibility</a></li> <li><a href="https://delvingbitcoin.org/t/cluster-mempool-rbf-thoughts/156">Cluster Mempool RBF Thoughts</a></li> </ul> <h4 id="definitions">Definitions</h4> <ul> <li><strong>Fee Rate:</strong> The fee of a transaction divided by its size.</li> <li><strong>Chunk:</strong> A grouped list of related transactions that should be mined together.</li> <li><strong>Chunk Fee Rate:</strong> The total fees of all transactions in a chunk divided by their total size.</li> <li><strong>Fee Rate Diagram:</strong> A monotonically decreasing list of chunks used to plot a graph where the y-axis represents the fee and the x-axis represents transaction size.</li> </ul> <h3 id="block-template-fee-increase">Block Template Fee Increase</h3> <p>The objective is to determine the potential <strong>fee increase</strong> of a block template as the mempool evolves, <strong>without rebuilding</strong> the block template using the node’s block assembler.</p> <p>Given a previously built block template, compute/save:</p> \[\begin{aligned} F_{\text{threshold}} &amp;= \text{(the fee increase that warrants a new block template build)} \\ F &amp;= \sum_{i=1}^{n} f_i \text{( sum of fees of all chunks in the current block template)} \\ S &amp;= \sum_{i=1}^{n} s_i \text{( sum of size of all chunks in the current block template)} \\ F_{\text{modified}} &amp;= F \text{(modified total fee after mempool updates)} \\ S_{\text{modified}} &amp;= S \text{(modified total size after mempool updates)} \\ W &amp;= \text{maximum allowed block weight} \\ L &amp;= \text{the lowest-fee-rate (worst) chunk currently in the block template} \\ A &amp;= \lbrace\rbrace \text{(list of newly added chunks with } r_i &gt; r_L \text{, sorted descending by fee rate)} \\ R &amp;= \lbrace\rbrace \text{(list of removed chunks with } r_i \ge r_L \text{, sorted ascending by fee rate)} \\ r_i &amp;= \frac{f_i}{s_i} \text{(fee rate of chunk } i) \end{aligned}\] <h4 id="mempool-update-scenarios">Mempool Update Scenarios</h4> <p>When a new transaction enters the mempool, two primary cases occur:</p> <ol> <li> <p><strong>Addition without in-mempool conflicts</strong> The transaction connects to zero or more existing clusters. A new linearization is computed for the affected clusters, producing both an <strong>old</strong> and <strong>new</strong> fee rate diagram.</p> </li> <li> <p><strong>Addition with in-mempool conflicts</strong> The transaction conflicts with one or more existing transactions in the mempool. The connected clusters are re-linearized, generating both <strong>old</strong> and <strong>new</strong> fee rate diagrams.</p> </li> </ol> <div class="row mt-4"> <div class="col-md-9"> <figure> <img class="img-fluid rounded z-depth-1" src="/assets/img/detecting-fee-increase/fig1.png" alt="Example of mempool addition"/> <figcaption class="mt-2 text-muted"> Naive example of mempool addition of b′ that improves the fee rate of b. </figcaption> </figure> </div> </div> <p>In both cases, the addition is accepted <em>iff</em> the <strong>new fee rate diagram</strong> is strictly better.</p> <p>There is also a rare case where update has <strong>only the old diagram</strong>, for example, when the mempool is full and the lowest-fee chunk is evicted. This is uncommon, as miners typically run nodes with large mempools, but it should still be handled.</p> <h4 id="after-an-update">After an Update</h4> <p><strong>If there is an old diagram:</strong></p> <p>Initialize an empty temporary list \(\text{New}_R = \{\}\).</p> <p>For each chunk \(c\) in the <strong>old fee rate diagram</strong>, if \(r_c \ge r_L\), add \(c\) to \(\text{New}_R\).</p> <p>Maintain \(\text{New}_R\) in <strong>ascending order</strong> by fee rate.</p> <p>Iterate through \(\text{New}_R\):</p> <p>For each chunk \(c \in \text{New}_R\) (from lowest fee rate):</p> \[\begin{cases} \text{if } c = L: &amp; \text{Remove } L \text{ from block template} \\ &amp; \text{Update } L \text{ to the new worst chunk in the remaining block template} \\ &amp; \text{Remove } c \text{ from } \text{New}_R \\ &amp; F_{\text{modified}} \leftarrow F_{\text{modified}} - f_c \\ &amp; S_{\text{modified}} \leftarrow S_{\text{modified}} - s_c \\ \text{else if } r_c &gt; r_L: &amp; \text{Exit loop — all remaining chunks have } r_c &gt; r_L \end{cases}\] <p>After the loop, add all remaining chunks in \(\text{New}_R\) to the persistent set \(R\) (chunks with \(r_c &gt; r_L\) that were removed but not equal to the old \(L\)).</p> <p><strong>If there is a new diagram:</strong></p> <p>For each chunk \(c\) in the <strong>new fee rate diagram</strong>, if \(r_c &gt; r_L\), add \(c\) to \(A\) (maintained in descending fee rate order).</p> <h3 id="evaluating-potential-fee-increase">Evaluating Potential Fee Increase</h3> <p><strong>Phase 1: Remove evicted chunks from block template</strong></p> <p>Loop through the block template chunks. For each chunk \(c\):</p> <ul> <li>If any chunk in \(R\) matches \(c\), remove it from the block template. Subtract its fees from \(F_{\text{modified}}\) and its size from \(S_{\text{modified}}\).</li> </ul> <p>Clear \(R\) afterward.</p> <p><strong>Phase 2: Perform naive merge</strong></p> <p>Initialize:</p> \[F_{\text{naive}} = F_{\text{modified}}, \quad S_{\text{naive}} = S_{\text{modified}}\] <p>Iterate through chunks in \(A\) (in descending fee rate order):</p> \[\text{for each chunk } a_i \in A:\] <p>If \(S_{\text{naive}} + s_{a_i} \le W\), then:</p> \[\begin{cases} F_{\text{naive}} \leftarrow F_{\text{naive}} + f_{a_i} \\ S_{\text{naive}} \leftarrow S_{\text{naive}} + s_{a_i} \end{cases}\] <p>Compute:</p> \[\Delta F = F_{\text{naive}} - F\] <ul> <li><strong>If</strong> \(\Delta F \ge F_{\text{threshold}}\): rebuild the block template.</li> <li><strong>If</strong> all chunks in \(A\) are added and \(\Delta F &lt; F_{\text{threshold}}\): stop (insufficient improvement).</li> </ul> <p><strong>Phase 3: Iterative merge (if naive merge is inconclusive)</strong></p> <p>If the naive merge shows potential but is inconclusive, perform an <strong>iterative merge</strong> of the block template chunks and chunks in \(A\):</p> <ul> <li> <p>Initialize an empty block template and fill it by selecting the best chunks from both the existing template and \(A\).</p> </li> <li> <p>Stop when:</p> <ul> <li>Block weight \(W\) is reached,</li> <li>No chunk from the template or \(A\) will fit, or</li> <li>The iteration limit is reached.</li> </ul> </li> </ul> <p>Compute:</p> \[\Delta F_{\text{new}} = F_{\text{new}} - F\] <ul> <li><strong>If</strong> \(\Delta F_{\text{new}} \ge F_{\text{threshold}}\): build and return the new block template.</li> </ul> <p><strong>Phase 4: Update state</strong></p> <p>After building a new block template:</p> <ul> <li>Clear \(A\)</li> <li>Set the new template as the current one</li> <li>Update \(L\) to the worst chunk in the new template</li> <li>Update \(F_{\text{modified}} = F_{\text{new}}\), \(S_{\text{modified}} = S_{\text{new}}\)</li> </ul> <h3 id="implementation-note">Implementation Note</h3> <p>This computation can be handled asynchronously by a <strong>Block Template Manager</strong> (as proposed in <a href="https://github.com/bitcoin/bitcoin/issues/33389">Bitcoin Core Issue #33389</a>). It should operate independently of <code class="language-plaintext highlighter-rouge">cs_main</code> and mempool locks by using a validation interface notification executed in a scheduler thread after each mempool update. This notification provides both <strong>old and new fee rate diagrams</strong>, which is also useful for the block policy estimator [2]. The Block Template Manager maintains its own internal locks to ensure thread safety without blocking mempool or transaction relay operations.</p> <h3 id="limitation">Limitation</h3> <p>This approach does not account for bin-packing effects at the block template tail [3].</p> <h3 id="references">References</h3> <p>[0] <a href="https://github.com/bitcoin/bitcoin/issues/27677">Proposal for a new mempool design</a></p> <p>[1] <a href="https://github.com/bitcoin/bitcoin/issues/28676">Cluster Mempool</a></p> <p>[2] <a href="https://delvingbitcoin.org/t/package-aware-fee-estimator-post-cluster-mempool/312">Package-Aware Fee Estimator Post Cluster Mempool</a></p> <p>[3] <a href="https://en.wikipedia.org/wiki/Bin_packing_problem">Bin Packing Problem</a></p>]]></content><author><name></name></author><category term="technical"/><category term="bitcoin"/><category term="mempool"/><category term="mining"/><summary type="html"><![CDATA[A method to track potential fee increases in block templates without full rebuilds using Cluster Mempool features]]></summary></entry><entry><title type="html">Analyzing Mining Pool Behavior to Address Bitcoin Core’s Double Coinbase Reservation Issue</title><link href="https://ismaelsadeeq.github.io/blog/2025/analyzing-mining-pool-behavior-to-address-bitcoin-core-double-coinbase-reservation-issue/" rel="alternate" type="text/html" title="Analyzing Mining Pool Behavior to Address Bitcoin Core’s Double Coinbase Reservation Issue"/><published>2025-01-01T00:00:00+00:00</published><updated>2025-01-01T00:00:00+00:00</updated><id>https://ismaelsadeeq.github.io/blog/2025/analyzing-mining-pool-behavior-to-address-bitcoin-core-double-coinbase-reservation-issue</id><content type="html" xml:base="https://ismaelsadeeq.github.io/blog/2025/analyzing-mining-pool-behavior-to-address-bitcoin-core-double-coinbase-reservation-issue/"><![CDATA[<p>In theory, Bitcoin Core’s block-building algorithm reserves <strong>4000 WU</strong> for block header, transaction count and miners’ coinbase transactions.<br/> This means it should generate a block template with a weight of <strong>3,996,000 WU</strong>.<br/> However, in practice, this is not the case due to an accidental double-reservation bug (<a href="https://github.com/bitcoin/bitcoin/issues/21950">see #21950</a>).<br/> As a result, Bitcoin Core generates block templates with a weight of <strong>3,992,000 WU</strong>.</p> <p>There is an ongoing attempt to fix this issue (<a href="https://github.com/bitcoin/bitcoin/pull/31384">see #31384</a>), but there are <a href="https://github.com/bitcoin/bitcoin/pull/31384#pullrequestreview-2489253785">concerns</a> that fixing the issue could lead to some miners generating invalid block templates.<br/> If the PR were to be merged, mining pools using the updated Bitcoin Core version must ensure the sum of the coinbase transaction weight and the weight of all additional transactions added to the block template must not exceed <strong>4000 WU</strong>.<br/> Otherwise, the block will exceed the consensus limit for the maximum block weight (<strong>4,000,000 WU</strong>) and be invalid.</p> <p>The proposed PR fixes the double reservation issue, increasing the block template size by <strong>4000 WU</strong>, resulting in blocks with a weight of <strong>3,996,000 WU</strong> as expected.</p> <p>Miners or pools needing more than <strong>4000 WU</strong> for their coinbase transactions should configure <code class="language-plaintext highlighter-rouge">bitcoind</code> with a lower <code class="language-plaintext highlighter-rouge">-blockmaxweight</code> option.<br/> Example: <code class="language-plaintext highlighter-rouge">-blockmaxweight=3999000</code> frees up an additional <strong>1000 WU</strong>.</p> <p><strong>Blocks Analyzed:</strong> 107,313<br/> <strong>Period:</strong> 24th December 2022 to 23rd December 2024</p> <h3 id="methodology">Methodology</h3> <ul> <li>Used <a href="https://github.com/stickies-v/py-bitcoinkernel/">libbitcoinkernel</a> to read blocks from disk.</li> <li>Each block deserialized; <a href="https://github.com/bitcoin-data/mining-pools">bitcoin-data/mining-pools</a> tags used to match the block to a mining pool. Block weight, coinbase transaction, and mining pool info saved to disk.</li> <li>Analysis generated using <a href="https://github.com/ismaelsadeeq/mining-analysis?tab=readme-ov-file#3-generate_resultspy">this script</a>.</li> <li>Charts generated using <a href="https://github.com/ismaelsadeeq/mining-analysis?tab=readme-ov-file#4-graph-generation-scripts">these scripts</a>.</li> <li>More methodology details: <a href="https://github.com/ismaelsadeeq/mining-analysis">GitHub - mining-analysis</a>.</li> </ul> <hr/> <h3 id="pools-generating-blocks-with-coinbase-weight--4000-wu">Pools Generating Blocks with Coinbase Weight &gt; 4000 WU</h3> <table> <thead> <tr> <th>Pool Name</th> <th>Average Coinbase weight</th> <th>Lowest Coinbase weight</th> <th>Highest coinbase weight</th> </tr> </thead> <tbody> <tr> <td>Ocean.xyz</td> <td>6994</td> <td>5308 (865820)</td> <td>9272 (863471)</td> </tr> <tr> <td>Unknown pool</td> <td>7432</td> <td>7000 (824116)</td> <td>7864 (785117)</td> </tr> </tbody> </table> <div class="row mt-4"> <div class="col-md-9"> <figure> <img class="img-fluid rounded z-depth-1" src="/assets/img/mining-analysis/fig1.png" alt="Large Coinbase Transaction Weights"/> <figcaption class="mt-2 text-muted"> Distribution of coinbase transaction weights for pools generating blocks with coinbase weights &gt; 4000 WU. </figcaption> </figure> </div> </div> <hr/> <h3 id="remaining-mining-pools-coinbase-stats">Remaining Mining Pools Coinbase Stats</h3> <table> <thead> <tr> <th>Pool Name</th> <th>Average Coinbase Weight</th> <th>Lowest Coinbase Weight</th> <th>Highest Coinbase Weight</th> </tr> </thead> <tbody> <tr> <td>ViaBTC</td> <td>1,128</td> <td>864 (778363)</td> <td>1,284 (868424)</td> </tr> <tr> <td>Foundry USA</td> <td>834</td> <td>748 (833764)</td> <td>1,192 (868391)</td> </tr> <tr> <td>F2Pool</td> <td>1,610</td> <td>1,176 (787112)</td> <td>1,832 (868388)</td> </tr> <tr> <td>AntPool</td> <td>1,357</td> <td>732 (814783)</td> <td>1,612 (875136)</td> </tr> <tr> <td>Binance Pool</td> <td>1,151</td> <td>684 (789485)</td> <td>1,480 (810101)</td> </tr> <tr> <td>SpiderPool</td> <td>997</td> <td>704 (817123)</td> <td>1,296 (863176)</td> </tr> <tr> <td>Braiins Pool</td> <td>1,056</td> <td>684 (853433)</td> <td>1,232 (785389)</td> </tr> <tr> <td>MARA Pool</td> <td>815</td> <td>720 (800883)</td> <td>1,016 (833308)</td> </tr> <tr> <td>SecPool</td> <td>1,371</td> <td>1,088 (808120)</td> <td>1,460 (871380)</td> </tr> <tr> <td>Poolin</td> <td>1,110</td> <td>728 (852695)</td> <td>1,336 (795979)</td> </tr> <tr> <td>Luxor</td> <td>1,237</td> <td>780 (770527)</td> <td>1,480 (868404)</td> </tr> <tr> <td>BTC.com</td> <td>1,205</td> <td>740 (796334)</td> <td>1,476 (811469)</td> </tr> <tr> <td>Pega Pool</td> <td>688</td> <td>688 (800892)</td> <td>688 (800892)</td> </tr> <tr> <td>Ultimus Pool</td> <td>1,209</td> <td>1,056 (853449)</td> <td>1,444 (844214)</td> </tr> <tr> <td>EMCDPool</td> <td>1,082</td> <td>1,080 (804771)</td> <td>1,304 (795962)</td> </tr> <tr> <td>SBI Crypto</td> <td>716</td> <td>716 (833247)</td> <td>716 (833247)</td> </tr> <tr> <td>NiceHash</td> <td>786</td> <td>780 (804872)</td> <td>828 (870207)</td> </tr> <tr> <td>Titan</td> <td>696</td> <td>696 (770484)</td> <td>696 (770484)</td> </tr> <tr> <td>WhitePool</td> <td>887</td> <td>676 (820630)</td> <td>1,304 (865060)</td> </tr> <tr> <td>KuCoin Pool</td> <td>1,095</td> <td>1,092 (777136)</td> <td>1,316 (796122)</td> </tr> <tr> <td>CleanIncentive</td> <td>728</td> <td>728 (819134)</td> <td>728 (819134)</td> </tr> <tr> <td>1THash</td> <td>1,084</td> <td>1,084 (837937)</td> <td>1,088 (864350)</td> </tr> <tr> <td>EclipseMC</td> <td>860</td> <td>860 (858559)</td> <td>860 (858559)</td> </tr> <tr> <td>Terra Pool</td> <td>844</td> <td>844 (780190)</td> <td>844 (780190)</td> </tr> <tr> <td>CKPool</td> <td>856</td> <td>856 (863890)</td> <td>856 (863890)</td> </tr> </tbody> </table> <div class="row mt-4"> <div class="col-md-9"> <figure> <img class="img-fluid rounded z-depth-1" src="/assets/img/mining-analysis/fig2.png" alt="Line Chart of Coinbase Transaction Weights"/> <figcaption class="mt-2 text-muted"> Average, minimum, and maximum coinbase transaction weights for various mining pools. </figcaption> </figure> </div> </div> <hr/> <h3 id="pools-with-blocks--3996000-wu">Pools with Blocks (&gt; 3,996,000 WU)</h3> <table> <thead> <tr> <th>Pool Name</th> <th>Average Block Weight</th> <th>Lowest Block Weight</th> <th>Highest Block Weight</th> </tr> </thead> <tbody> <tr> <td>F2Pool</td> <td>3,997,857</td> <td>3,994,044 (828959)</td> <td>3,998,554 (779729)</td> </tr> </tbody> </table> <h3 id="pools-with-blocks--3996000-wu-1">Pools with Blocks (&lt; 3,996,000 WU)</h3> <table> <thead> <tr> <th>Pool Name</th> <th>Average Block Weight</th> <th>Lowest Block Weight</th> <th>Highest Block Weight</th> </tr> </thead> <tbody> <tr> <td>Foundry USA</td> <td>3,993,030</td> <td>3,992,749 (813879)</td> <td>3,993,523 (874770)</td> </tr> <tr> <td>Binance Pool</td> <td>3,993,348</td> <td>3,992,753 (784937)</td> <td>3,993,768 (846996)</td> </tr> <tr> <td>MARA Pool</td> <td>3,993,017</td> <td>3,992,721 (802653)</td> <td>3,994,944 (859968)</td> </tr> <tr> <td>Luxor</td> <td>3,993,434</td> <td>3,992,782 (768718)</td> <td>3,993,811 (841510)</td> </tr> <tr> <td>AntPool</td> <td>3,993,554</td> <td>3,992,868 (814783)</td> <td>3,993,918 (873367)</td> </tr> <tr> <td>ViaBTC</td> <td>3,993,324</td> <td>3,992,881 (782955)</td> <td>3,993,612 (872513)</td> </tr> <tr> <td>Poolin</td> <td>3,993,308</td> <td>3,992,987 (855538)</td> <td>3,993,613 (795979)</td> </tr> <tr> <td>Braiins Pool</td> <td>3,993,251</td> <td>3,992,695 (853433)</td> <td>3,993,416 (853776)</td> </tr> <tr> <td>SBI Crypto</td> <td>3,992,911</td> <td>3,992,717 (796840)</td> <td>3,993,047 (834797)</td> </tr> <tr> <td>Ultimus Pool</td> <td>3,993,407</td> <td>3,993,076 (852748)</td> <td>3,993,768 (842345)</td> </tr> <tr> <td>BTC.com</td> <td>3,993,399</td> <td>3,992,745 (796409)</td> <td>3,993,781 (806063)</td> </tr> <tr> <td>SpiderPool</td> <td>3,993,190</td> <td>3,992,912 (856599)</td> <td>3,993,616 (864899)</td> </tr> <tr> <td>WhitePool</td> <td>3,993,072</td> <td>3,992,677 (825268)</td> <td>3,993,631 (872281)</td> </tr> <tr> <td>Ocean.xyz</td> <td>3,988,137</td> <td>3,986,489 (865820)</td> <td>3,990,301 (863471)</td> </tr> <tr> <td>EMCDPool</td> <td>3,993,273</td> <td>3,993,081 (781934)</td> <td>3,993,428 (796046)</td> </tr> <tr> <td>Pega Pool</td> <td>3,992,894</td> <td>3,992,690 (783729)</td> <td>3,993,018 (781576)</td> </tr> <tr> <td>Titan</td> <td>3,992,974</td> <td>3,992,926 (768641)</td> <td>3,993,020 (769939)</td> </tr> <tr> <td>KuCoin Pool</td> <td>3,993,282</td> <td>3,993,101 (781030)</td> <td>3,993,504 (796188)</td> </tr> <tr> <td>Terra Pool</td> <td>3,993,032</td> <td>3,992,863 (776927)</td> <td>3,993,172 (780396)</td> </tr> <tr> <td>CleanIncentive</td> <td>3,992,946</td> <td>3,992,748 (823029)</td> <td>3,993,038 (822604)</td> </tr> <tr> <td>1THash</td> <td>3,993,276</td> <td>3,993,085 (837937)</td> <td>3,993,412 (814830)</td> </tr> <tr> <td>NiceHash</td> <td>3,992,987</td> <td>3,992,782 (789503)</td> <td>3,993,148 (785085)</td> </tr> <tr> <td>CKPool</td> <td>3,993,102</td> <td>3,992,897 (863890)</td> <td>3,993,181 (822636)</td> </tr> </tbody> </table> <div class="row mt-4"> <div class="col-md-9"> <figure> <img class="img-fluid rounded z-depth-1" src="/assets/img/mining-analysis/fig3.png" alt="Block Weights for Pools"/> <figcaption class="mt-2 text-muted"> Average, minimum, and maximum block weights for various mining pools. </figcaption> </figure> </div> </div> <hr/> <h3 id="key-observations">Key Observations</h3> <ul> <li>Most mining pools adhere to Bitcoin Core’s default setup, keeping coinbase transaction weights well below <strong>4000 WU</strong>. Two pools stand out: <ul> <li><strong>Ocean.xyz</strong>: Avg coinbase <strong>6,994 WU</strong>, min <strong>5,308 WU</strong>, max <strong>9,272 WU</strong>, avg block weight <strong>3,986,489 WU</strong>. Likely uses reduced <code class="language-plaintext highlighter-rouge">-blockmaxweight</code>.</li> <li><strong>Unknown Pool</strong>: Avg coinbase <strong>7,432 WU</strong>, max <strong>7,864 WU</strong>, very low block weight—unusual.</li> </ul> </li> <li><strong>F2Pool</strong>: Avg block <strong>3,997,857 WU</strong>, e.g., block <strong>779729</strong> reached <strong>3,998,554 WU</strong> with coinbase <strong>1,588 WU</strong>, showing efficient block use.</li> <li>Majority of pools (Foundry USA, Binance Pool, AntPool) produce blocks ~<strong>3,993,000 WU</strong>, showing underutilization due to double-reservation bug.</li> <li>Small increase in block weights accounted for by block headers (<a href="https://delvingbitcoin.org/t/analyzing-mining-pool-behavior-to-address-bitcoin-cores-double-coinbase-reservation-issue/1351/4?u=ismaelsadeeq">see @0xB10C</a>).</li> </ul> <p>Fixing double-reservation increases block templates to <strong>3,996,000 WU</strong>, allowing full block weight utilization while preserving <strong>4000 WU</strong> for coinbase and other additions.</p> <p>Miners needing extra space (like Ocean.xyz) can set <code class="language-plaintext highlighter-rouge">-blockmaxweight=3999000</code> to free <strong>1000 WU</strong> for larger coinbase transactions, ensuring consensus compliance.</p>]]></content><author><name></name></author><category term="technical"/><category term="analysis"/><category term="bitcoin"/><category term="mining"/><category term="analysis"/><category term="block-template"/><summary type="html"><![CDATA[Analysis of mining pool behavior regarding Bitcoin Core’s double coinbase reservation bug and its impact on block template weights.]]></summary></entry><entry><title type="html">Bitcoind Block Policy Fee Rate Estimator Modes Analysis</title><link href="https://ismaelsadeeq.github.io/blog/2024/bitcoind-policy-estimator-analysis/" rel="alternate" type="text/html" title="Bitcoind Block Policy Fee Rate Estimator Modes Analysis"/><published>2024-06-24T00:00:00+00:00</published><updated>2024-06-24T00:00:00+00:00</updated><id>https://ismaelsadeeq.github.io/blog/2024/bitcoind-policy-estimator-analysis</id><content type="html" xml:base="https://ismaelsadeeq.github.io/blog/2024/bitcoind-policy-estimator-analysis/"><![CDATA[<p>This analysis examines the fee estimation data from Block <code class="language-plaintext highlighter-rouge">846887</code> to <code class="language-plaintext highlighter-rouge">847322</code>, covering a total of <code class="language-plaintext highlighter-rouge">435</code> blocks, to analyze the difference between estimates from the <a href="https://johnnewbery.com/an-intro-to-bitcoin-core-fee-estimation/">Bitcoind Policy Estimator</a> in <code class="language-plaintext highlighter-rouge">conservative</code> and <code class="language-plaintext highlighter-rouge">economical</code> modes.</p> <h3 id="methodology">Methodology</h3> <ul> <li>Logged and traced conservative and economical fee estimates every minute.</li> <li>Logged and traced all connected blocks’ percentile fee rates (<a href="https://github.com/ismaelsadeeq/bitcoin/tree/new-fee-estimator-data">branch implementation</a>).</li> <li>Collected and cleaned data from both the traced and debug logs (<a href="https://gist.github.com/ismaelsadeeq/6a6531e9b96bfeed20178e353b187332">data</a>).</li> <li>Analyzed the data by plotting Bitcoind conservative and economical estimates against the confirmed block target (50th–5th percentile fee rate range).</li> </ul> <h3 id="definitions">Definitions</h3> <ul> <li><strong>Conservative mode</strong>: The <code class="language-plaintext highlighter-rouge">estimatesmartfee</code> RPC mode which considers a longer history of blocks. It potentially returns a higher fee rate and is more likely to be sufficient for the desired target, but it is not as responsive to short-term drops in the prevailing fee market.</li> <li><strong>Economical mode</strong>: The <code class="language-plaintext highlighter-rouge">estimatesmartfee</code> RPC mode where estimates are potentially lower and more responsive to short-term drops in the prevailing fee market.</li> <li><strong>Overpaid estimates</strong>: An estimate above the 50th percentile fee rate of the target block.</li> <li><strong>Underpaid estimates</strong>: An estimate below the 5th percentile fee rate of the target block.</li> <li><strong>Estimates within range</strong>: An estimate that falls between the 5th and 50th percentile fee rates of the target block.</li> </ul> <h3 id="data-summary-for-bitcoind-estimatesmartfee">Data Summary for Bitcoind <code class="language-plaintext highlighter-rouge">estimatesmartfee</code></h3> <p>A total of <strong>13,718</strong> estimates were made from <code class="language-plaintext highlighter-rouge">2024-06-07 12:18:25</code> to <code class="language-plaintext highlighter-rouge">2024-06-10 07:48:05</code>, spanning Block <code class="language-plaintext highlighter-rouge">846886</code> to Block <code class="language-plaintext highlighter-rouge">847321</code>, with confirmation targets of 1 and 2 blocks.</p> <table> <thead> <tr> <th>Estimator</th> <th>Overpaid Estimates</th> <th>Underpaid Estimates</th> <th>Estimates Within Range</th> </tr> </thead> <tbody> <tr> <td>Bitcoind Conservative</td> <td>3760 (96.14%)</td> <td>66 (1.69%)</td> <td>85 (2.17%)</td> </tr> <tr> <td>Bitcoind Economic</td> <td>3033 (77.55%)</td> <td>433 (11.07%)</td> <td>445 (11.38%)</td> </tr> </tbody> </table> <h3 id="log-scale-graphs">Log-Scale Graphs</h3> <div class="row mt-4"> <div class="col-md-9"> <figure> <img class="img-fluid rounded z-depth-1" src="https://hackmd.io/_uploads/Syp1xVPBC.png" alt="Log-scale estimates block 846887–847087"/> <figcaption class="mt-2 text-muted"> Estimates from block <code>846887</code> to <code>847087</code> plotted on a log scale. </figcaption> </figure> </div> </div> <div class="row mt-4"> <div class="col-md-9"> <figure> <img class="img-fluid rounded z-depth-1" src="https://hackmd.io/_uploads/SyKxxVDHC.png" alt="Log-scale estimates block 847087–847287"/> <figcaption class="mt-2 text-muted"> Estimates from block <code>847087</code> to <code>847287</code> plotted on a log scale. </figcaption> </figure> </div> </div> <h2 id="absolute-value-scale">Absolute Value Scale</h2> <div class="row mt-4"> <div class="col-md-9"> <figure> <img class="img-fluid rounded z-depth-1" src="https://hackmd.io/_uploads/r1svgVwBR.png" alt="Absolute scale estimates block 846887–847087"/> <figcaption class="mt-2 text-muted"> Estimates from block <code>846887</code> to <code>847087</code> plotted using absolute values. </figcaption> </figure> </div> </div> <div class="row mt-4"> <div class="col-md-9"> <figure> <img class="img-fluid rounded z-depth-1" src="https://hackmd.io/_uploads/HyUueNwS0.png" alt="Absolute scale estimates block 847087–847287"/> <figcaption class="mt-2 text-muted"> Estimates from block <code>847087</code> to <code>847287</code> plotted using absolute values. </figcaption> </figure> </div> </div> <p>You can recreate these graphs, summaries, and more from the repository using the <a href="https://github.com/ismaelsadeeq/fee-estimates-analysis/tree/analyse-bitcoind-estimates"><code class="language-plaintext highlighter-rouge">analyse-bitcoind-estimates</code> branch</a>.</p> <h3 id="key-findings">Key Findings</h3> <ul> <li>This empirical data shows that the economical mode has a much lower overestimation compared to the conservative mode.</li> <li>These graphs show that the economical mode responds much quicker to recent fee market adjustments than the conservative mode.</li> <li>A previous analysis used the economical mode, but this was incorrectly reported in <a href="https://github.com/bitcoin/bitcoin/issues/30009">Bitcoin issue #30009</a>.</li> </ul> <h3 id="worst-case-overestimation-example">Worst-Case Overestimation Example</h3> <p>Block <code class="language-plaintext highlighter-rouge">847088</code> was confirmed with a 50th percentile fee rate of <strong>38.7 sat/vB</strong>.</p> <ul> <li><code class="language-plaintext highlighter-rouge">estimatesmartfee</code> conservative mode: <strong>505.7 sat/vB</strong></li> <li><code class="language-plaintext highlighter-rouge">estimatesmartfee</code> economical mode: <strong>48.3 sat/vB</strong></li> </ul> <div class="row mt-4"> <div class="col-md-7"> <figure> <img class="img-fluid rounded z-depth-1" src="https://hackmd.io/_uploads/BkDOfNwHC.png" alt="Worst-case fee estimate comparison"/> <figcaption class="mt-2 text-muted"> Worst-case overestimation example for block <code>847088</code>. </figcaption> </figure> </div> </div> <p>Many transactions paid this high fee to get included, as seen <a href="https://mempool.space/block/0000000000000000000074877b16a3ca2a512114f731fc76e226ec77dcfc38db">here</a>.</p> <p>For an average P2WPKH 2-input 2-output transaction weighing approximately <code class="language-plaintext highlighter-rouge">208.5</code> vbytes, the costs are:</p> <ul> <li><strong>Bitcoind economical estimate</strong>: <code class="language-plaintext highlighter-rouge">208.5 × 48.3 = 10071 satoshis (≈ $6.73)</code></li> <li><strong>Bitcoind conservative estimate</strong>: <code class="language-plaintext highlighter-rouge">208.5 × 505.7 = 105438 satoshis (≈ $70.52)</code></li> </ul> <p>Using the conservative estimate results in paying <strong>15× more than necessary</strong>. This excessive overestimation persists for extended periods, causing many transactions to significantly overpay.</p> <div class="row mt-4"> <div class="col-md-7"> <figure> <img class="img-fluid rounded z-depth-1" src="https://hackmd.io/_uploads/BJijzNDBC.png" alt="Persistent conservative overestimation"/> <figcaption class="mt-2 text-muted"> Persistent overestimation by the conservative estimator across multiple blocks. </figcaption> </figure> </div> </div> <p>This analysis reveals that the overestimation by the conservative mode is not an isolated incident but a recurring trend. Given the current fee market behavior, this warrants modifying the default estimation mode to <strong>economical</strong> to reduce systematic overpayment.</p> <hr/> <h3 id="references">References</h3> <ul> <li><a href="https://delvingbitcoin.org/t/mempool-based-fee-estimation-on-bitcoin-core/703/8">Mempool-based fee estimation on Bitcoin Core</a></li> <li><a href="https://github.com/bitcoin/bitcoin/pull/30157">Bitcoin Core PR #30157</a></li> </ul>]]></content><author><name></name></author><category term="technical"/><category term="analysis"/><category term="Bitcoin"/><category term="Bitcoind"/><category term="Feerate-Estimation"/><summary type="html"><![CDATA[Analysis of Bitcoind estimatesmartfee modes]]></summary></entry><entry><title type="html">Challenges with Estimating Transaction Fee Rates</title><link href="https://ismaelsadeeq.github.io/blog/2023/challenges-with-estimating-tx-feerate/" rel="alternate" type="text/html" title="Challenges with Estimating Transaction Fee Rates"/><published>2023-11-16T00:00:00+00:00</published><updated>2023-11-16T00:00:00+00:00</updated><id>https://ismaelsadeeq.github.io/blog/2023/challenges-with-estimating-tx-feerate</id><content type="html" xml:base="https://ismaelsadeeq.github.io/blog/2023/challenges-with-estimating-tx-feerate/"><![CDATA[<p><strong>Fee estimation</strong> is the process of predicting the fee rate that a transaction should pay in order to be included in a certain number of blocks in the future.<br/> The fee rate is the fee paid per unit of transaction size.</p> <p>Fee estimation is critical because it determines when a transaction is likely to be mined.<br/> Transactions are prioritized based on their fee rate; higher rates ensure faster confirmations, as miners favor them to maximize revenue.</p> <p>Especially during periods of congestion, low–fee-rate transactions may linger and potentially never confirm.</p> <p>Users must determine suitable fee rates, balancing confirmation speed and cost, aided by fee estimators.</p> <p>Fee estimation is probabilistic and utilizes various data sources, including <strong>historical block transactions</strong>, <strong>historical block transactions that the mempool has seen confirmed</strong>, and <strong>unconfirmed mempool transactions</strong>.</p> <h3 id="challenges-of-fee-estimation-with-historical-block-transactions">Challenges of Fee Estimation with Historical Block Transactions</h3> <ul> <li>Gameable by miners: miners including high–fee-rate transactions in their mined blocks can influence future fee estimates. Those high–fee-rate transactions will impact future predictions.</li> <li>This method overlooks the current state of miners’ mempools, which may be congested with high–fee-rate transactions or shallow with low–fee-rate transactions. Relying solely on previous block fee rates can lead to overpayment or underpayment.</li> </ul> <h3 id="challenges-of-mempool-based-fee-estimation">Challenges of Mempool-Based Fee Estimation</h3> <ul> <li>Accurate fee estimation depends on having a fully validating node with a synchronized mempool.</li> <li>Mempool differences: the user’s mempool may differ from the miner’s mempool, leading to inaccurate predictions.</li> <li>Relying on external fee estimation services might introduce the risk of service providers colluding with miners to artificially inflate fee estimates.</li> </ul> <h3 id="challenges-of-fee-estimation-with-historical-blocks-and-mempool-transactions-data">Challenges of Fee Estimation with Historical Blocks and Mempool Transactions Data</h3> <ul> <li>This approach, based on transactions in the node’s mempool that have been confirmed, reduces the risk of miners manipulating future predictions by publishing high–fee-rate transactions. The threat of other miners picking up these high–fee-rate transactions discourages manipulation. However, this method does not consider the current mempool size and is <em>package-unaware</em>, which reduces data points and, in some cases, leads to inaccurate assumptions.</li> </ul> <h3 id="how-historical-blocks-and-mempool-transactions-data-fee-estimation-falls-short">How Historical Blocks and Mempool Transactions Data Fee Estimation Falls Short</h3> <p>Bitcoin Core uses this historical block and mempool transaction data to estimate fees. The component that handles fee estimation is called <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code>.</p> <blockquote> <p>“Because it’s solely based on historical data (looking at how long mempool transactions take to confirm), it cannot react quickly to changing conditions.”<br/> — sipa</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> observes how long mempool transactions historically take to confirm. It assumes that if some number of mempool transactions with a certain fee rate have been confirmed after a specific number of blocks in the past, using that same fee rate for your transaction will likely result in a similar confirmation time.</p> <p>However, this assumption may not hold if the mempool’s state changes. The historical data may not accurately reflect the current situation.</p> <blockquote> <p>“Because it’s aiming to match seen behaviour rather than a requirement, if some non-negligible fraction of users keeps paying a certain high feerate, it may try to match that, even if it is unnecessary for confirmation.”<br/> — sipa</p> </blockquote> <p>If a node’s mempool primarily contains high–fee-rate transactions due to mempool differences, the mempool transactions that end up confirming will also be high–fee-rate transactions. This can lead to the <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> producing high fee rate estimates. Transactions with such high fee rates will likely be confirmed in a short time, but at the cost of paying more than necessary.</p> <p>Similarly, if the node’s mempool predominantly comprises low–fee-rate transactions, and the mempool transactions that confirm also have low fee rates, the <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> will tend to provide lower fee estimates. Miners may be less likely to pick such transactions because they are not sufficiently incentivized to include them in a block. This reflects the estimator’s tendency to align with the observed behaviour of transactions that have historically been confirmed.</p> <blockquote> <p>“The new fee estimator is much better at reacting to large volatility in tx throughput, but ignores the mempool.”<br/> — kallewoof</p> </blockquote> <p>This statement implies that the <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> is designed to react and adjust fee estimates based on historical data and trends related to how mempool transaction fee rates are confirmed over time. It takes into account the past behaviour of transactions in terms of their fee rates and confirmation times to predict future fee rates. However, it may not consider real-time or current conditions in the mempool when making these estimations, which could lead to discrepancies or inaccuracies during times of sudden changes or fluctuations in transaction throughput.</p> <h3 id="analysis-to-confirm-that-cblockpolicyestimator-is-unreliable-in-some-situations">Analysis to Confirm That <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> Is Unreliable in Some Situations</h3> <p>I have been watching the blockchain for a while to verify the behavior of the <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code>. One instance where the mempool experienced congestion was between blocks <strong>812593</strong> and <strong>812596</strong>. This is an example of where the Bitcoin Core fee estimator was not reliable.</p> <h4 id="fee-rate-estimates-from-812593-to-812596">Fee Rate Estimates from <strong>812593</strong> to <strong>812596</strong></h4> <table> <thead> <tr> <th>Block Height</th> <th>EstimateSmartFee (2 blocks)</th> <th>Mempool-Based Fee Estimate (High priority)</th> <th>Average Fee Rate</th> <th>Median Fee Rate</th> </tr> </thead> <tbody> <tr> <td>Immediately after 812593 confirmed</td> <td>18 s/vb</td> <td>22 s/vb</td> <td>N/A</td> <td>N/A</td> </tr> <tr> <td>45 minutes after 812593</td> <td>18 s/vb</td> <td>33 s/vb</td> <td>N/A</td> <td>N/A</td> </tr> <tr> <td>Block 812594 was confirmed</td> <td>18 s/vb</td> <td>33 s/vb</td> <td>44 s/vb</td> <td>33 s/vb</td> </tr> <tr> <td>Block 812595 was confirmed</td> <td>18 s/vb</td> <td>22 s/vb</td> <td>25 s/vb</td> <td>22 s/vb</td> </tr> <tr> <td>Block 812596 was confirmed</td> <td>20 s/vb</td> <td>22 s/vb</td> <td>23 s/vb</td> <td>19 s/vb</td> </tr> </tbody> </table> <div class="row mt-4"> <div class="col-md-9"> <figure> <img class="img-fluid rounded z-depth-1" src="/assets/img/challenges-of-fee-estimation/fig1.png" alt="Example of mempool addition"/> <figcaption class="mt-2 text-muted"> Graph of how it changes </figcaption> </figure> </div> </div> <p>The estimates above demonstrate how the <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> operates during congestion, completely independent of the mempool’s condition.</p> <p>Thanks to Ishanaam and other Bitcoin Core developers, I was able to classify the wallets used by the mempool transaction dumps between <strong>812594</strong> and <strong>812596</strong> with the <a href="https://ishaana.com/blog/wallet_fingerprinting/">wallet fingerprinting</a> tool.</p> <p>I identified Bitcoin Core transactions by their wallet fingerprints and determined whether they use estimates from the <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code>, as well as the outcomes of transactions that use the <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> and those that do not.</p> <p>After block <strong>812593</strong> was mined, a new block was not found for more than an hour. This caused the mempool to become congested, and some users started broadcasting high–fee-rate transactions or fee-bumping already published ones to increase the chances of their transactions being picked by miners. This, in turn, raised the mempool-based fee estimate to <strong>33 s/vb</strong>, while <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> was still providing <strong>18 s/vb</strong> for high-priority fee estimates.</p> <p>The mempool state at that moment is shown below.</p> <iframe width="600" height="371" seamless="" frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQrOX3TK3AswjhfNfc9gOx93Z-ODDID2GQlapoW0YlwB_v4lkjx17_A-5CasONVr7kyhBne2x6qmXpm/pubchart?oid=1181013940&amp;format=interactive"></iframe> <p>The high-priority target fee rate of <strong>18 s/vb</strong> from <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> is significantly below the ancestor score of <strong>38%</strong> of fingerprinted Bitcoin Core transactions.</p> <p>This demonstrates unequivocally that those transactions obtain their fee estimates from somewhere else. For example, they may be using the <code class="language-plaintext highlighter-rouge">fee_rate</code> field of the <code class="language-plaintext highlighter-rouge">sendtoaddress</code> RPC with the <a href="https://mempool.space">mempool.space</a> fee rate estimate.</p> <iframe width="600" height="371" seamless="" frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQrOX3TK3AswjhfNfc9gOx93Z-ODDID2GQlapoW0YlwB_v4lkjx17_A-5CasONVr7kyhBne2x6qmXpm/pubchart?oid=1061368107&amp;format=interactive"></iframe> <p>There are <strong>116</strong> transactions whose ancestor score falls within the <strong>18 s/vb</strong> high-priority estimate range of <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code>, accounting for <strong>12.6%</strong> of all Bitcoin Core transactions.</p> <p>It is implied that the remaining <strong>49.4%</strong> of Bitcoin Core transactions may or may not be using <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> as their fee estimator, because their ancestor scores were below that of <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code>.</p> <p>After an hour and a few minutes, block <strong>812594</strong> was mined.</p> <p>Below is the mempool state after <strong>812594</strong>.</p> <iframe width="600" height="371" seamless="" frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQrOX3TK3AswjhfNfc9gOx93Z-ODDID2GQlapoW0YlwB_v4lkjx17_A-5CasONVr7kyhBne2x6qmXpm/pubchart?oid=1278002772&amp;format=interactive"></iframe> <p><strong>30%</strong> of fingerprinted Bitcoin Core transactions after <strong>812594</strong> had an ancestor score above the <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> high-priority target fee rate.</p> <p>Some transactions paying more than the <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> high-priority target fee rate were mined.</p> <iframe width="600" height="371" seamless="" frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQrOX3TK3AswjhfNfc9gOx93Z-ODDID2GQlapoW0YlwB_v4lkjx17_A-5CasONVr7kyhBne2x6qmXpm/pubchart?oid=330620633&amp;format=interactive"></iframe> <p>Transactions whose ancestor scores are within the <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> high-priority estimate range increased to <strong>128</strong>, or <strong>14%</strong> of transactions.</p> <p>None of the transactions using the high-priority estimate were mined, and additional transactions were broadcast with the same <strong>18 s/vb</strong> estimate. <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> continued to provide an <strong>18 s/vb</strong> estimate, while the mempool remained congested and the mempool-based fee estimate stayed at <strong>33 s/vb</strong>.</p> <p>Block <strong>812595</strong> was discovered shortly afterward.</p> <iframe width="600" height="371" seamless="" frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQrOX3TK3AswjhfNfc9gOx93Z-ODDID2GQlapoW0YlwB_v4lkjx17_A-5CasONVr7kyhBne2x6qmXpm/pubchart?oid=1405156454&amp;format=interactive"></iframe> <p>Only <strong>12%</strong> of fingerprinted Bitcoin Core transactions after <strong>812595</strong> had an ancestor score higher than the high-priority target fee rate set by <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code>.</p> <iframe width="600" height="371" seamless="" frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQrOX3TK3AswjhfNfc9gOx93Z-ODDID2GQlapoW0YlwB_v4lkjx17_A-5CasONVr7kyhBne2x6qmXpm/pubchart?oid=687911508&amp;format=interactive"></iframe> <p>Transactions whose ancestor score is within the <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> high-priority estimate range rose to <strong>139</strong>, or <strong>18%</strong> of Bitcoin Core transactions. <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> assured that a transaction using <strong>18 s/vb</strong> would confirm within the next two blocks.</p> <p>Two blocks passed, and transactions using that estimate were still not confirmed. <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> remained at <strong>18 s/vb</strong>. At that time, the mempool-based fee estimator reduced its estimate to <strong>22 s/vb</strong>, while <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> continued providing <strong>18 s/vb</strong>.</p> <p>Block <strong>812596</strong> was mined a few minutes later.</p> <iframe width="600" height="371" seamless="" frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQrOX3TK3AswjhfNfc9gOx93Z-ODDID2GQlapoW0YlwB_v4lkjx17_A-5CasONVr7kyhBne2x6qmXpm/pubchart?oid=1428828125&amp;format=interactive"></iframe> <p>The mempool contained only <strong>0.5%</strong> of fingerprinted Bitcoin Core transactions whose ancestor score was higher than the <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> high-priority target fee rate.</p> <p>Almost all Bitcoin Core transactions with higher fees than those suggested by <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code>, and which used different fee estimation sources, were mined.</p> <iframe width="600" height="371" seamless="" frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQrOX3TK3AswjhfNfc9gOx93Z-ODDID2GQlapoW0YlwB_v4lkjx17_A-5CasONVr7kyhBne2x6qmXpm/pubchart?oid=470892768&amp;format=interactive"></iframe> <p>However, even after three blocks, there were still about <strong>77</strong> transactions stuck in the mempool. This is most likely due to the ancestor score of <strong>18 s/vb</strong>, which accounted for <strong>14%</strong> of the fingerprinted Bitcoin Core transactions.</p> <p>During this period, <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> began adjusting its estimate from <strong>18 s/vb</strong> to <strong>20 s/vb</strong>, due to the higher fee rates observed in mempool transactions that were confirmed.</p> <h3 id="why-fee-estimation-is-challenging">Why Fee Estimation Is Challenging</h3> <p>Estimating fees is challenging for several reasons. One major hurdle is unpredictable block confirmation times. Sometimes blocks are mined quickly, while at other times they can take over an hour.</p> <p>When blocks are mined quickly, miners’ mempools are cleared, resulting in a shallow mempool with lower–fee-rate transactions because higher–fee-rate transactions have already been mined. This reduces the fee rate required for a transaction to be included in the next block. If fee estimators do not consider the current state of the mempool, users may overpay.</p> <p>Conversely, during congested periods with longer block confirmation times, failing to consider the state and size of the mempool can result in transactions becoming stuck due to underpayment.</p> <p>Accounting for the state of the mempool is difficult because each user has a unique view of it, influenced by connectivity and policy rules. If a user’s mempool is not well synchronized with miners’ mempools, fee estimates may be biased.</p> <p>For example, if a user’s mempool mostly contains low–fee-rate transactions while miners primarily see high–fee-rate transactions, the user’s transactions may get stuck due to insufficient fees. Conversely, if a user’s mempool is dominated by high–fee-rate transactions while miners mostly see lower–fee-rate transactions, the user may overpay.</p> <p>Failing to consider the current mempool state can lead to delayed or overpriced transactions, and mismatched mempool views further complicate accurate fee estimation.</p> <h4 id="improvement-proposal">Improvement Proposal</h4> <p>A mempool-based fee estimator is currently being proposed in Bitcoin Core. It will check whether nodes’ mempools roughly align with the global mempool observed by miners. If a node’s mempool policy differs significantly from that of miners, <code class="language-plaintext highlighter-rouge">CBlockPolicyEstimator</code> should be used instead.</p> <p>Until it is observed that a node has a mempool nearly identical to that of miners, a mempool-based fee estimator will not be reliable.</p> <p>These are heuristics, and the proposal is still in its early stages. More insights and reviews are required to ensure the checks function as intended.</p> <h4 id="in-summary">In Summary</h4> <p>Because of the constraints discussed above, no fee estimate can ever be completely accurate in predicting future events. If your transaction takes significantly longer to confirm than expected, don’t worry.</p> <p>In most cases, you have two tools available: <em>replace-by-fee</em> and <em>CPFP</em>—the fee-bumping tag team. While the details of replace-by-fee and CPFP, along with scenarios where they may not rescue a stuck transaction, are beyond the scope of this article, they make for an interesting <a href="https://gist.github.com/glozow/3de85d7e4fc58c5723f8fcbf21e5e795">read</a>.</p> <p>If a transaction overpaid, however—tough luck. There is no “undo” button. A valid transaction will remain valid and will eventually be picked up by a miner. Consider it your generous contribution to a miner’s retirement fund.</p>]]></content><author><name></name></author><category term="technical"/><category term="Bitcoin"/><category term="Transaction"/><category term="Feerate-Estimation"/><summary type="html"><![CDATA[This post explores the reasons why estimating how much to pay for your transaction as fee is challenging, and the ways to overcome these challenges.]]></summary></entry><entry><title type="html">Tips and Techniques for Constructing Private Transactions with Privatetx library</title><link href="https://ismaelsadeeq.github.io/blog/2023/tips-and-techniques-for-constructing-private-txs/" rel="alternate" type="text/html" title="Tips and Techniques for Constructing Private Transactions with Privatetx library"/><published>2023-05-01T16:40:16+00:00</published><updated>2023-05-01T16:40:16+00:00</updated><id>https://ismaelsadeeq.github.io/blog/2023/tips-and-techniques-for-constructing-private-txs</id><content type="html" xml:base="https://ismaelsadeeq.github.io/blog/2023/tips-and-techniques-for-constructing-private-txs/"><![CDATA[<h3 id="introduction">Introduction</h3> <p>The Bitcoin blockchain offers users the ability to conduct pseudonymous transactions, but privacy can easily be compromised with common missteps such as reusing addresses, improper coin selection and transaction construction. Worse is taking full custody of users keys and subsequently attaching names or identity documents (KYC) to corresponding keys. As a result, chain analysis tools can easily identify individual users, trace the flow of bitcoins, and de-annonymize transactions. This has significant implications for the privacy and security of Bitcoin users. In this article, we will explore some steps that Bitcoin service builders can take to improve the privacy of their users and minimize the impact of chain analysis tools. By implementing these steps, service providers can offer their users a more secure and private experience on the Bitcoin network, while helping to preserve the core values of Bitcoin as a decentralized and privacy-focused system.</p> <h3 id="keys-custody-and-identity-documents-kyc">Keys Custody and identity documents (KYC)</h3> <p>Service providers should avoid taking full custody of their users private keys and should not associate users’ names or identity documents (KYC) with their Bitcoin addresses. Features such as output descriptors can give users full control over their private keys while reducing service providers’ risks and responsibilities. By importing only the extended public key descriptor, users can recover their Bitcoin balance and transaction history without providing identifying information and provide their private key only when signing a transaction. Although some jurisdictions may require collecting user information, service providers should avoid doing so as much as possible to protect their users’ privacy and the Bitcoin system as a whole.</p> <p>If the above missteps are addressed, then it all comes down to how you construct your transaction. To enhance privacy, avoid reusing addresses when constructing transactions, and perform a coinjoin when aggregating inputs for a payment (combining multiple Bitcoin transactions into a single transaction) to break common input heuristics.</p> <h3 id="privatetx-lib"><a href="http://github.com/ismaelsadeeq/privateTx">Privatetx-lib</a></h3> <p>Privatetx-lib is a library that checks partially signed bitcoin transactions (PSBTs) and provides alerts on whether the given PSBT is vulnerable to common chain analysis heuristics. These heuristics are what chain analysis services use to extract information from transactions, as mentioned in <a href="https://medium.com/oxt-research/understanding-bitcoin-privacy-with-oxt-part-2-4-20010e0dab97">research by OXT</a> and the <a href="https://en.bitcoin.it/wiki/Privacy">Bitcoin privacy wiki</a>.</p> <p>PSBT’s are used as an input for privatetx-lib because finalized PSBTs contain information about transaction inputs, which enables the algorithm to check for these heuristics. This is unlike a serialized transaction that only provides the input’s transaction ID and output index. Additionally, PSBTs are the current standard used by Bitcoin applications. To learn more about PSBTs and how to use them in your application, refer to <a href="https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki">BIP 174</a>. These Heuristics are:</p> <h4 id="transaction-wide-address-reuse">Transaction Wide Address reuse</h4> <div class="row mt-3"> <div class="col-sm-8"> <img class="img-fluid rounded z-depth-1" src="/assets/img/privatetx/fig1.png" alt="Figure 1"/> </div> </div> <p><br/></p> <p>In the above diagram, the change address of the transaction is the same as the input address. This is bad for privacy because it reveals the owner of the address bc1qzjdnhtrplk32vecxfqz8hmmf3mnenvecmvwhhy as the one who paid 10 bitcoins to the address bc1qaekdm6unw8qr6f5gwg48vfjntqf0xj9zpldwl5 and received 4.8 bitcoins as change. This information can be used to link the owner of the input address with the owner of the output address.</p> <p>The best practice is to use a new address in the change output.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm-8"> <img class="img-fluid rounded z-depth-1" src="/assets/img/privatetx/fig2.png" alt="Figure 2"/> </div> </div> <p><br/></p> <p>This approach provides less certainty to an observer in the network about the nature of the outputs. By using a new address for the change output, it becomes less clear whether both outputs are payments or if one of them is a change.</p> <p>Call the private-tx checkAddressReuse function with your PSBT string and ensure that it passes the address reuse heuristic.</p> <h4 id="common-inputs">Common Inputs</h4> <p>If it’s an aggregation transaction, this heuristic will detect that the inputs are consolidated by one wallet for a payment.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm-8"> <img class="img-fluid rounded z-depth-1" src="/assets/img/privatetx/fig3.png" alt="Figure 1"/> </div> </div> <p><br/></p> <p>This transaction in the diagram above clearly indicates that the two inputs of 15 and 25 bitcoins were consolidated in order to perform the 35 bitcoin payment. The change output is likely to be the 4.8 bitcoin output.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm-8"> <img class="img-fluid rounded z-depth-1" src="/assets/img/privatetx/fig4.png" alt="Figure 4"/> </div> </div> <p><br/></p> <p>A common way to break the address reuse heuristic is to combine it with another transaction, commonly known as coinjoin, which helps to obscure the connection between the inputs and outputs of a transaction and make it difficult to determine whether they belong to the same user.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm-8"> <img class="img-fluid rounded z-depth-1" src="/assets/img/privatetx/fig5.png" alt="Figure 5"/> </div> </div> <p><br/></p> <p>In this newly constructed transaction with multiple inputs and payments, it will be difficult for an observer to distinguish between the payment outputs and the change output.</p> <h4 id="check-against-change-detection">Check against change detection</h4> <p>When it’s a distributing transaction, change outputs will be detected. To break the heuristic, you can perform coinjoin, change the script type to match the payment and avoid reusing addresses. It depends on the reason why the change was detected. Private-tx provides information on why change outputs were detected, such as address reuse being a change output, a different output script type indicating a payment, an output value greater than all input values being the payment output, non-round number outputs being change outputs, and the largest output value being the change output.</p> <p>Example of output with a different script type with the input.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm-8"> <img class="img-fluid rounded z-depth-1" src="/assets/img/privatetx/fig6.png" alt="Figure 6"/> </div> </div> <p><br/></p> <p>The 1 bitcoin output above is a P2SH, which clearly shows that it is the payment output, and the 0.99999 bitcoin output is the change output.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm-8"> <img class="img-fluid rounded z-depth-1" src="/assets/img/privatetx/fig7.png" alt="Figure 7"/> </div> </div> <p><br/></p> <p>To break these heuristics, change the change output address to P2SH.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm-8"> <img class="img-fluid rounded z-depth-1" src="/assets/img/privatetx/fig8.png" alt="Figure 8"/> </div> </div> <p><br/></p> <p>An observer of this transaction can not distinguish whether it is the payment or the change output.</p> <h4 id="peeling-transaction">Peeling transaction</h4> <p>It is common that exchanges make settlements in a peeling transaction format below.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm-8"> <img class="img-fluid rounded z-depth-1" src="/assets/img/privatetx/fig9.png" alt="Figure 9"/> </div> </div> <p><br/></p> <p>The 19.44444 bitcoin is clearly the change output, whereas 0.5 bitcoin is a payment.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm-8"> <img class="img-fluid rounded z-depth-1" src="/assets/img/privatetx/fig10.png" alt="Figure 10"/> </div> </div> <p><br/></p> <p>To break the peeling transaction heuristic, it is recommended for exchange builders to avoid peeling the transaction and improve the privacy of their transactions. Peeling transactions often occur due to the reuse of addresses and the accumulation of large amounts of bitcoin in a single address, resulting in a large value input that needs to be peeled off to settle a customer. Instead, it is suggested to avoid reusing addresses and have a low value output that can be used to settle a customer. By doing this, exchange builders can ensure the privacy of their transactions and avoid the detection of the peeling heuristic.</p> <p>You can use Private-tx to check whether a transaction is a peeling transaction or not.</p> <p>Check https://github.com/ismaelsadeeq/privateTx to learn how to install and use privatetx-lib, it is a JavaScript library and services that are based on TypeScript or JavaScript can leverage on privatetx-lib to improve how they construct their transaction and ensure they are resilient to chain analysis tools.</p> <p>Chain analysis tools use heuristics to analyze the Bitcoin blockchain transaction by transaction. These heuristics cluster wallets, predict their unspent balance, and track their payment history. The tools determine the change and payment outputs in a transaction and link the spending transaction of the change output to previous transactions. By checking for the reuse of the input or change output address, the tools create a graph of clusters of wallets and their payments over time, along with the remaining balance currently held.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm-8"> <img class="img-fluid rounded z-depth-1" src="/assets/img/privatetx/fig11.png" alt="Figure 11"/> </div> </div> <p><em>Image By Gaurav Agrawal Coinpath August 15, 2020</em></p> <p><br/></p> <p>However, this data alone is not enough to identify the real-world identities behind these wallets. That’s where collaboration with exchanges and wallets that require personal identifiable information comes into play. With this collaboration, chain analysis tools can link real identities with payments or wallets, potentially compromising the privacy of users.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm-8"> <img class="img-fluid rounded z-depth-1" src="/assets/img/privatetx/fig12.png" alt="Figure 12"/> </div> </div> <p><br/></p> <p>The above example in the diagram illustrates how the identity of a Bitcoin user was revealed due to privacy missteps by their wallet. This demonstrates how a compromise of privacy not only affects the victim, but also the people with whom they transact.</p> <h3 id="conclusion">Conclusion</h3> <p>Protecting user privacy is essential in preserving the core values of Bitcoin as a decentralized and privacy-focused system. Bitcoin service builders should take several steps to minimize the impact of chain analysis tools on their users by using of tools like privatetx-lib, which can help service providers improve how they construct their transactions. By implementing these steps, Bitcoin service providers can offer their users a more secure and private experience on the Bitcoin network, while protecting their privacy and maintaining their reputation as a privacy-focused service.</p>]]></content><author><name></name></author><category term="technical"/><category term="Privacy"/><category term="Bitcoin"/><category term="Transaction"/><category term="Chain-Analysis"/><summary type="html"><![CDATA[How to construct Bitcoin Transactions that are mystery to chain analysis]]></summary></entry></feed>